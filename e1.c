#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
//数出一个数的补码中有几个1
//int main()
//{
//	int a = 24;//10111  11000
//	int c = 0;
//	int count = 0;
//	while(a)	
//	{
//		c = a & 1;
//		if (c)
//			count++;
//		a = a >> 1;
//	}
//	printf("%d\n", count);
//	return 0;
//}

//int main()
//{
//	int i = 3,k = 4;
//	int a = i+++i+++i;//几个加号连在一起时，优先把最前面的两个加号当成自增运算符
//	//int a = i+++++k;是错误的，因为i++(i = i + 1)这个赋值语句不能++
//	//这也充分体现了加空格的重要性
//	printf("%d\n", a);
//	printf("%d\n", i);
//
//	int c = 2%(-2);
//	printf("%d\n", c);
//	return 0;
//}

//计算1 + ... + 100
//int tailRecur(int n, int res) 
//{
//    if (n == 0)
//        return res;
//    // 尾递归调用
//    return tailRecur(n - 1, res + n);
//}
//int main()
//{
//    int h = tailRecur(100, 0);
//    printf("%d\n", h);
//	return 0;
//}

//将一个数补码的某一位的0改成1
//int main()
//{
//	int a = 13;//00000000000000000000000000001101
//	//将倒数第5位改成1
//	//           00000000000000000000000000010000按位或13即可
//	//而这个数是 1 << n-1 得到的 
//
//	a = a | (1 << 4);//00000000000000000000000000011101
//	printf("%d\n", a);
//	//将29改回13(将某一位改成0)        11111111111111111111111111101111按位与29即可
//	//            而这个数是1<<n-1 再取反得到的
//	a = a & (~(1 << 4));
//	//a = a ^ (1 << 4);   也可以
//	printf("%d\n", a);
//	a > 1;
//	return 0;
//}

//结构体传参
//#include<string.h>
//typedef struct Stu
//{
//	char name[20];
//	int age;
//	double score;
//}s;
//	//形参是对实参的一份临时拷贝，改变形参的值不会改变实参的值
//	//所以要用指针来改变实参值；；而打印时打印实参和形参都一样
//void set_stu(s* p)
//{
//	(*p).age = 20;
//	(*p).score = 100.0;
//	strcpy((*p).name, "zhangsan");
//	/*p->age = 20;
//	p->score = 100.0;
//	strcpy(p->name, "zhangsan");*/
//}
//void print_stu(s ss)
//{
//	printf("%s\n", ss.name);
//	printf("%d\n", ss.age);
//	printf("%lf\n", ss.score);
//}
//int main()
//{
//	s stu;
//	set_stu(&stu);
//	print_stu(stu);
//	return 0;
//}

//整型提升：进行整形算术运算时，表达式中的字符(char)和短整型(short)操作数在使用前先转化为整型的
//最低精度为整型          整型提升是按照变量数据类型的符号位来提升的
//如果是unsigned char或unsigned short则最高位直接补0（按符号位提升，补的数和符号位相同）
//int main()
//{
//	//-1是整型的（32个bit）  10000000000000000000000000000001 原码
//	                       //11111111111111111111111111111110 反码
//	                       //11111111111111111111111111111111 补码
////而c是char类型的，只能存储8个bit，所以c中存有最低的8个位11111111
//	//整型提升时，由于符号位是1，所以补上24个1得到11111111111111111111111111111111
//	char c = -1;
//	char a = 6;
//	//6的补码：00000000000000000000000000000110
//	//a中存储的是00000110
//	char b = 125;
//	//125的补码是00000000000000000000000001111101
//	//b中存储的是01111101
//	char s = a + b;
//	//运算时a,b提升为整型，00000000000000000000000000000110
//	//                    +00000000000000000000000001111101 = 00000000000000000000000010000011
//	//但是s中存储的是最低的8位10000011（补码）
//	//打印时整型提升，按符号位提升，变成11111111111111111111111110000011（补码）
//	//这个补码实际表示的数为10000000000000000000000001111101   （即-125）
//	printf("%d\n", s);
//
//	char c1 = 1;
//	printf("%d\n", sizeof(c1));//char类型的c1本来占一个字节，
//	                           //但是在前面加上+或-时就相当于进行了运算，要提升为4个字节的整型
//	printf("%d\n", sizeof(+c1));
//	printf("%d\n", sizeof(-c1));
//	return 0;
//}
//删除数组中指定元素
//int main()
//{
//	int arr[] = { 1,3,2,4,2,5,6 };
//	int i = 0, j = 0;
//	for (i = 0; i < 7; i++)
//	{
//		if (arr[i] != 2)
//		{
//			arr[j++] = arr[i];
//		}		
//	}
//	for (i = 0; i < j; i++)
//	printf("%d\n", arr[i]);
//	return 0;
//}
//输入一个数组(每个数在1~100之间)，判断最大值与最小值的差
//int main()
//{
//	int arr[10];
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		scanf("%d", &arr[i]);
//	}
//	int min = arr[0];
//	int max = arr[0];
//	for (i = 0; i < 10; i++)//一次循环同时找到最大值和最小值
//	{
//		if (arr[i] > max)
//			max = arr[i];
//		if (arr[i] < min)
//			min = arr[i];
//	}
//	printf("%d\n", max - min);
//	return 0;
//}
//还可以在输入时直接判断
//int main()
//{
//	int arr[10];
//	int i = 0;
//	int min = 100;
//	int max = 0;
//	for (i = 0; i < 10; i++)
//	{
//		scanf("%d", &arr[i]);
//		if (arr[i] > max)
//			max = arr[i];
//		if (arr[i] < min)
//			min = arr[i];
//	}
//	printf("%d\n", max - min);
//	return 0;
//}